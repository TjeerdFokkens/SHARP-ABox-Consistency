import ABoxConsistency as ABC
from scipy import stats
import matplotlib.pyplot as plt
import numpy as np
from statsmodels.distributions.empirical_distribution import ECDF


simulations = ABC.plot_list(50, "abox2.txt")


#Making a nice workable data structure: a dictionary

sim = []
for i in simulations:
    j = i[:-1]
    s = i[0]
    for k in j[1:]:
        s=s+', '+k
    m = [s,i[-1]]
    sim.append(m)

#making the dictionary entries

dictionary = {}
for i in sim:
    run = i[0]
    dictionary[run] = []

#associating the data to the dictionary entries

for i in sim:
    run = i[0]
    time = i[1]
    dictionary[run].append(time)

print('These are the different runs:')
for k,v in dictionary.items():
    print(k)

data = str(dictionary)
f = open("dict.txt", "w")
f.write(data)
f.close()


s = open("dict.txt", "r")
dictionary = eval(s.read())


for i in ran(len(dictionary.items())):
    st = "sample_" + i + " = dictionary[list(dictionary.items())[" + i + "][0]]"
    print(st)
    exec(st)


print('Sample 1 order: ',list(dictionary.items())[0][0])
print('Sample 2 order: ',list(dictionary.items())[1][0])
print('Sample 3 order: ',list(dictionary.items())[2][0])

print('K-S test on samples 1 and 2: ', stats.kstest(sample_1, sample_2))
print('K-S test on samples 1 and 3: ', stats.kstest(sample_1, sample_3))
print('K-S test on samples 2 and 3: ', stats.kstest(sample_2, sample_3))

print('t test on samples 1 and 2: ', stats.ttest_ind(sample_1, sample_2, equal_var=False))
print('t test on samples 1 and 3: ', stats.ttest_ind(sample_1, sample_3, equal_var=False))
print('t test on samples 2 and 3: ', stats.ttest_ind(sample_2, sample_3, equal_var=False))

print('Sample 1 size: ',len(sample_1))
print('Sample 2 size: ',len(sample_2))
print('Sample 3 size: ',len(sample_3))


fig, ax = plt.subplots()
x = [1, 2, 3]
ax.eventplot((sample_1, sample_2, sample_3), orientation="horizontal", lineoffsets=x,
linewidth=0.75, linelength=0.75, color='darkcyan')
ax.set_xlabel('Time (s)')
ax.axes.yaxis.set_ticks([1.0, 2.0, 3.0])
ax.axes.yaxis.set_ticklabels(['Sample 1', 'Sample 2', 'Sample 3'])

plt.savefig('AnalysisThreeSamples.png', transparent=True, dpi=800)
#plt.show()

def lower(sam1, sam2):
    #For every value in sam1, count how many values in sam2 are strictly smaller.
    li1=[]
    for i in sam1:
        v = len(list(x for x in sam2 if x < i))
        li1.append(v)
    return li1

def same(sam1, sam2):
    #For every value in sam1, count how many values are equally large.
    li2=[]
    for i in sam1:
        v = len(list(x for x in sam2 if x == i))
        li2.append(v)
    return li2

def A_w(sam1, sam2):
    #Calculate the probability of superiority.
    l = lower(sam1,sam2)
    s = same(sam1,sam2)
    numerator = sum(l)+0.5*sum(s)
    denominator = len(sam1) * len(sam2)
    fraction = numerator/denominator
    return fraction

print('Effect size 1-2', A_w(sample_1,sample_2))
print('Effect size 1-3', A_w(sample_1,sample_3))
print('Effect size 2-3', A_w(sample_2,sample_3))

def cumulplot(sample1,sample2,save=False):
    ecdf1 = ECDF(sample1)
    ecdf2 = ECDF(sample2)
    fig, ax = plt.subplots()
    ax.set_xlabel('Time (s)')
    plt.plot(ecdf1.x, ecdf1.y)
    plt.plot(ecdf2.x, ecdf2.y)
    if save ==True:
        plt.savefig('EmpirDistrFunc.png', transparent=True, dpi=800)
    plt.show()

cumulplot(sample_2,sample_3,True)


'''

def simulation_plot(iterations, abox, desired_bin_size):
    #Takes the number of simulations, the abox it's working with and the desired size of the bins in the plot.
    #It returns a plot with the desired criteria using the results of the simulations.
    colour = 'darkseagreen'
    sim_list = []
    for i in plot_list(iterations, abox):
        sim_list.append(i[-1])
    data = sim_list
    bins = compute_histogram_bins(data, desired_bin_size)
    min_val = bins[0]
    max_val = bins[-1]
    length = len(data)
    norm_fac = 1/(length)
    weights = np.ones(shape = length)*norm_fac

    fig, (ax1, ax2) = plt.subplots(2, 1, gridspec_kw={'height_ratios': [3, 1]}, tight_layout=True, sharex=True)

    ax1.grid(visible=None, axis='x')
    ax1.grid(linestyle=':', axis='y')
    ax1.set(xticks=np.arange(min_val-desired_bin_size, max_val+2*desired_bin_size, desired_bin_size))
    ax1.set_title('Simulated time of inference')
    ax1.hist(data, bins=bins, color=colour, weights=weights*100, linewidth=0.5, edgecolor="white")
    ax1.yaxis.set_major_locator(MaxNLocator(steps=[1, 2, 4, 5, 10]))
    ax1.set_ylabel('relative frequency %')
    ax1.spines["right"].set_visible(False)
    ax1.spines["top"].set_visible(False)
    ax1.spines["left"].set_visible(False)
    ax1.yaxis.set_ticks_position('none')
    ax1.xaxis.set_ticks_position('none')

    timeintervals, linelengths, offsets = compute_line_lengths(data)

    ax2.eventplot(timeintervals, orientation="horizontal", linewidth=1, color=colour, linelengths = linelengths, lineoffsets = offsets)
    ax2.get_yaxis().set_visible(False)
    ax2.yaxis.set_major_locator(MaxNLocator(steps=[1, 2, 4, 5, 10]))
    ax2.grid(linestyle=':', axis='x')
    ax2.set_xlabel('time (s)')
    ax2.spines["right"].set_visible(False)
    ax2.spines["top"].set_visible(False)
    ax2.spines["left"].set_visible(False)
    ax2.xaxis.set_ticks_position('none')

def compute_line_lengths(data):
    #The different data points prepared in an array for the plot.
    total = len(data)
    di = dict((i, data.count(i)) for i in data)
    di2 = list(di.keys())
    timeintervals = np.array([[el] for el in di])
    #The corresponding length of the lines.
    l = []
    for i in di2:
        num = di[i]
        l.append(num)
    linelengths = [element/total*len(timeintervals) for element in l]
    #The offsets such that the eventlines are aligned.
    offsets = [ 0 for el in linelengths]
    return timeintervals, linelengths, offsets

def compute_histogram_bins(data, desired_bin_size):
    #Takes a list with the simulation times and the desired bin size.
    #Returns the boundaries of the bins in a list.
    min_val = min(data)
    max_val = max(data)
    min_boundary = np.round(np.floor(min_val/desired_bin_size)*desired_bin_size,1)
    max_boundary = np.round(np.ceil(max_val/desired_bin_size)*desired_bin_size,1)
    n_bins = int(round((max_boundary - min_boundary) / desired_bin_size,0))
    bins = np.linspace(min_boundary, max_boundary, n_bins+1)
    return bins


simulation_plot(70, "abox2.txt", 0.2)
plt.savefig('ABoxSimulationPlot2.png', transparent=True, dpi=1200)
plt.show()


def from_abox_to_data(abox, iterations):
    aBoxCon = initial(learning=True)
    md1.module1(aBoxCon)
    md2.module2(aBoxCon)
    md3.module3(aBoxCon)
    md4.module4(aBoxCon)
    md5.module5(aBoxCon)
    par.AddAboxFromFile(abox,aBoxCon)
    #vec = trace(aBoxCon, 'PROCEDURAL', action='RULE SELECTED')
    data = plot_list(iterations, abox)
    data_points = []
    for i in range(0,iterations):
        data_point = data[i][-1]
        data_points.append(data_point)
    return data_points
print(from_abox_to_data('a:A, a:(E&(B&C))',100))

#f = open("abox2.txt", 'r')
#abox = f.read().replace('\n', ' ')

from Aboxes_incon import aboxes_inconsistent
j = 0
for i in aboxes_inconsistent:
    j+=1
    print(j)
    aBoxCon = initial(learning=True)
    md1.module1(aBoxCon)
    md2.module2(aBoxCon)
    md3.module3(aBoxCon)
    md4.module4(aBoxCon)
    md5.module5(aBoxCon)
    par.AddAboxFromFile(i,aBoxCon)
    vec = trace(aBoxCon, 'manual', action='KEY')
#aBoxCon_sim = aBoxCon.simulation(realtime=False,gui=False)
#aBoxCon_sim.run(10)
'''


'''
it = 10
abox1 = 'a:A, a:(-A&(B&C))'
abox2 = 'a:A, a:(E&(B&C))'
data1 = plot_list(it, abox1)
data2 = plot_list(it, abox2)
dict = {'a:A, a:(-A&(B&C))':data1, 'a:A, a:(E&(B&C))':data2}



#s = open("dict.txt", "r")
#dictionary = eval(s.read())

dict = {'a:A, a:(-A&(B&C))': [2.1756, 2.1774, 2.1725, 2.1775, 2.1738, 2.1732, 2.1754, 2.1777, 2.1744, 2.1739, 2.1705, 2.1747, 2.1763, 2.173, 2.1726, 2.175, 2.1755, 2.1732, 2.1718, 2.1755, 2.1708, 2.1755, 2.1768, 2.175, 2.1754, 2.177, 2.1744, 2.1757, 2.1767, 2.1759, 2.1728, 2.176, 2.1751, 2.1779, 2.1731, 2.1774, 2.1766, 2.1755, 2.1749, 2.1778, 2.1758, 2.1738, 2.177, 2.1751, 2.1767, 2.1753, 2.176, 2.1732, 2.1737, 2.174, 2.1737, 2.1722, 2.1744, 2.1738, 2.1752, 2.1778, 2.1721, 2.178, 2.1732, 2.1783, 2.1763, 2.1788, 2.1742, 2.1759, 2.1741, 2.1764, 2.1787, 2.1736, 2.1775, 2.1766, 2.1721, 2.1774, 2.1745, 2.1747, 2.1746, 2.1758, 2.1724, 2.1764, 2.183, 2.1743, 2.1749, 2.1746, 2.1728, 2.1764, 2.1753, 2.1729, 2.1755, 2.1758, 2.1771, 2.1772, 2.1763, 2.1736, 2.1742, 2.1772, 2.1774, 2.1757, 2.1746, 2.1769, 2.1742, 2.1738], 'a:A, a:(E&(B&C))': [6.9112, 6.8806, 6.8793, 6.9082, 6.9323, 6.9062, 6.9345, 6.9119, 7.0701, 7.0926, 6.9098, 7.0681, 6.9065, 6.9356, 6.8819, 7.0697, 7.0598, 7.041, 7.0339, 6.9138, 7.0415, 6.8781, 7.0684, 7.0665, 7.0357, 7.0684, 7.0636, 7.0678, 7.0667, 7.0653, 7.0671, 7.0378, 7.0676, 7.0317, 6.9366, 6.9325, 6.9326, 7.0633, 6.9382, 6.8851, 7.062, 7.0414, 6.9072, 7.0397, 6.8816, 7.0709, 6.8839, 6.906, 7.0403, 7.0916, 6.9319, 6.913, 6.9394, 7.0919, 6.9297, 6.9061, 7.0857, 7.0879, 7.0622, 6.9105, 6.8807, 7.0644, 6.8803, 7.0394, 7.088, 7.0618, 7.0356, 7.0625, 6.9317, 7.0649, 6.9094, 7.0869, 7.0698, 6.8858, 6.9322, 6.9047, 6.911, 7.0907, 6.9081, 6.9124, 6.8792, 6.8836, 6.9307, 6.9071, 7.0581, 6.9288, 7.0702, 6.9093, 6.8873, 7.0639, 6.9364, 7.087, 6.9091, 6.9131, 7.0615, 6.9108, 6.8846, 7.0352, 6.8848, 6.9171]}

vars = []
min_value = 100
max_value = 0
for i in range(len(dict.items())):
    st1 = "Sample_" + str(i) + " = dict[list(dict.items())[" + str(i) + "][0]]"
    exec(st1)
    st2 = "Sample_" + str(i)
    exec("min_value = min(min_value,min(" + st2 + "))")
    exec("max_value = max(max_value,max(" + st2 + "))")
    vars.append(st2)


#Defining the colours
color_map = cm.get_cmap('plasma')
pick = list(np.linspace(0,1,len(dict.items())))
colors = []
for i in pick:
    colors.append(color_map(i))

gs = grid_spec.GridSpec(len(vars),1)
fig = plt.figure(figsize=(10,6))

lx=min_value * 0.95 #the left x limit
rx=max_value * 1.04 #the right x limit

i = 0
y_max=0
x_d = np.linspace(lx,rx, 1000)
logprob = []

for var in vars:
    exec("x = np.array(" + var + ")")
    kde = KernelDensity(bandwidth=0.1, kernel='gaussian')
    kde.fit(x[:,None])
    plot_log_data = kde.score_samples(x_d[:, None])
    plot_data = np.exp(plot_log_data)
    logprob.append(plot_data)
    y_max = max(y_max,max(plot_data))

y_max = y_max * 1.05

ax_objs = []
for var in vars:
    ind = vars.index(var)

    ax_objs.append(fig.add_subplot(gs[i:i+1, 0:]))
    # plotting the distribution
    ax_objs[-1].plot(x_d, np.array(logprob[ind]),color="#f0f0f0",lw=0.5)
    ax_objs[-1].fill_between(x_d, logprob[ind], alpha=1,color=colors[i])


    # setting uniform x and y lims
    ax_objs[-1].set_xlim(lx,rx)
    ax_objs[-1].set_ylim(0,y_max)

    # make background transparent
    rect = ax_objs[-1].patch
    rect.set_alpha(0)

    # remove borders, axis ticks, and labels
    ax_objs[-1].set_yticklabels([])
    ax_objs[-1].yaxis.set_visible(False)

    if i == len(vars)-1:
        ax_objs[-1].set_xlabel("Inference time (s)", fontsize=14,fontweight="bold")
    else:
        ax_objs[-1].set_xticklabels([])

    spines = ["top","right","left","bottom"]
    for s in spines:
        ax_objs[-1].spines[s].set_visible(False)

    adj_var = var.replace("_"," ")
    ax_objs[-1].text(lx-0.02,0,adj_var,fontweight="bold",fontsize=10,ha="right")


    i += 1

gs.update(hspace=-0.6)

fig.text(0.07,0.85,"Distribution inference times for three different runs",fontsize=18)

plt.tight_layout()
plt.show()
'''
